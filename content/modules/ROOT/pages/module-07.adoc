# Module 7: Bonus

== Create a Virtual Machine Template based on the VM created in Module3

You noticed in Module-3 that creating a Virtual Machine takes some time (around 10 minutes in this case)... +
When using Trident, you can enable the `Cross Namespace Volume Clone` feature to rapidly create VM from a template. +
This functionality benefits from the NetApp FlexClone feature, which creates efficient clones, without copying data.

Let's create a new VM Template based on the one you started.
 
metadata:
  name: primary-pvc
  namespace: 
  annotations:
    trident.netapp.io/cloneToNamespace: .*

=== Create a Virtual Machine from this new template 

apiVersion: trident.netapp.io/v1
kind: TridentVolumeReference
metadata:
  name: secondary-pvc
  namespace: cnvc-secondary
spec:
  pvcName: primary-pvc
  pvcNamespace: cnvc-primary


apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: secondary-pvc
  namespace: cnvc-secondary
  annotations:
    trident.netapp.io/cloneFromPVC: primary-pvc
    trident.netapp.io/cloneFromNamespace: cnvc-primary
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 10Gi
  storageClassName: storage-class-iscsi

[#wordpress]
== Disaster Recovery for your Wordpress application

You can follow here the same methodology you applied in the _Module-06_ for the Virtual Machine.

=== Setup the mirroring

You first need to retrieve the application ID on the PROD cluster using the command line. +
We will use the _oc config_ command line to switch between clusters context.

[.lines_space]
[.console-input]
[source,bash,role=execute]
----
oc config use-context PROD
SRCAPPID=$(tridentctl-protect get app wordpress -n wordpress -o json | jq -r .metadata.uid) && echo $SRCAPPID
----

With that information, you can create the mirror relationship on the DR cluster. +

Let's first switch context to point to the DR cluster:
[.lines_space]
[.console-input]
[source,bash,role=execute]
----
oc config use-context DR
----

As we use a YAML manifest, you also need to create the target namespace on the DR cluster.
[.lines_space]
[.console-input]
[source,bash,role=execute]
----
oc create ns wordpressdr

cat << EOF | oc apply -f -
apiVersion: protect.trident.netapp.io/v1
kind: AppMirrorRelationship
metadata:
  name: wpamr1
  namespace: wordpressdr
spec:
  desiredState: Established
  destinationAppVaultRef: lab-vault
  namespaceMapping:
  - destination: wordpressdr
    source: wordpress
  recurrenceRule: |-
    DTSTART:20240901T000200Z
    RRULE:FREQ=MINUTELY;INTERVAL=5
  sourceAppVaultRef: lab-vault
  sourceApplicationName: wordpress
  sourceApplicationUID: $SRCAPPID
  storageClassName: storage-class-nfs
EOF
----
Let's check the status of this new object on the DR cluster:
[.lines_space]
[.console-input]
[source,bash,role=execute]
----
tridentctl-protect get amr -n wordpressdr
----
[.console-output]
[source,bash]
----
+----------+--------------+-----------------+---------------+--------------+-----+-------+
|   NAME   |  SOURCE APP  | DESTINATION APP | DESIRED STATE |     STATE    | AGE | ERROR |
+----------+--------------+-----------------+---------------+--------------+-----+-------+
|  wpamr1  |  lab-vault   |    lab-vault    | Established   | Establishing | 41s |       |
+----------+--------------+-----------------+---------------+--------------+-----+-------+
----
It will take a couple of minutes for the mirroring to be setup, or `Established` in the Trident language.
[.lines_space]
[.console-input]
[source,bash,role=execute]
----
tridentctl protect get amr -n wordpressdr
----
[.console-output]
[source,bash]
----
+----------+--------------+-----------------+---------------+-------------+-------+-------+
|   NAME   |  SOURCE APP  | DESTINATION APP | DESIRED STATE |    STATE    |  AGE  | ERROR |
+----------+--------------+-----------------+---------------+-------------+-------+-------+
|  wpamr1  |  lab-vault   |    lab-vault    | Established   | Established |  1m30 |       |
+----------+--------------+-----------------+---------------+-------------+-------+-------+
----
Let's verify what we currently have in the target namespace:
[.lines_space]
[.console-input]
[source,bash,role=execute]
----
oc get -n wordpressdr svc,po,pvc
----
[.console-output]
[source,bash]
----
NAME                                             STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS        VOLUMEATTRIBUTESCLASS   AGE
persistentvolumeclaim/data-wordpress-mariadb-0   Bound    pvc-1fc62930-31da-4d2d-92ca-4449fe13211c   8Gi        RWO            storage-class-nfs   <unset>                 2m35s
persistentvolumeclaim/wordpress                  Bound    pvc-29440095-169e-4524-94f7-e45e03e1e2d6   10Gi       RWO            storage-class-nfs   <unset>                 2m35s
----
As expected, you only see the PVC for now.

=== Failover your application

Failover your application is pretty straight forward. +
You just need to _patch_ the AMR on the DR cluster.

[.lines_space]
[.console-input]
[source,bash,role=execute]
----
oc patch amr wpamr1 -n wordpressdr --type=merge -p '{"spec":{"desiredState":"Promoted"}}'
----
Fairly quickly, you should get to the following result:
[.lines_space]
[.console-input]
[source,bash,role=execute]
----
tridentctl-protect get amr -n wordpressdr
----
[.console-output]
[source,bash]
----
+----------+--------------+-----------------+---------------+-------------+-------+-------+
|   NAME   |  SOURCE APP  | DESTINATION APP | DESIRED STATE |    STATE    |  AGE  | ERROR |
+----------+--------------+-----------------+---------------+-------------+-------+-------+
|  wpamr1  |  lab-vault   |    lab-vault    |   Promoted    |   Promoted  |  20s  |       |
+----------+--------------+-----------------+---------------+-------------+-------+-------+
----

Once in the `Promoted` state, let's check the content of our namespace:
[.lines_space]
[.console-input]
[source,bash,role=execute]
----
oc get -n wordpressdr svc,po,pvc
----
[.console-output]
[source,bash]
----
NAME                                 TYPE           CLUSTER-IP       EXTERNAL-IP                                                              PORT(S)                      AGE
service/wordpress                    LoadBalancer   172.30.104.107   a6fe2051eeb554284a7b3d398c119b63-831257922.us-east-2.elb.amazonaws.com   80:30175/TCP,443:30394/TCP   70s
service/wordpress-mariadb            ClusterIP      172.30.227.139   <none>                                                                   3306/TCP                     69s
service/wordpress-mariadb-headless   ClusterIP      None             <none>                                                                   3306/TCP                     69s

NAME                             READY   STATUS    RESTARTS   AGE
pod/wordpress-64f8c88c45-hns76   1/1     Running   0          70s
pod/wordpress-mariadb-0          1/1     Running   0          69s

NAME                                             STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS        VOLUMEATTRIBUTESCLASS   AGE
persistentvolumeclaim/data-wordpress-mariadb-0   Bound    pvc-1fc62930-31da-4d2d-92ca-4449fe13211c   8Gi        RWO            storage-class-nfs   <unset>                 5m4s
persistentvolumeclaim/wordpress                  Bound    pvc-29440095-169e-4524-94f7-e45e03e1e2d6   10Gi       RWO            storage-class-nfs   <unset>                 5m4s
----

As you can see, everything is back! +
If you connect on your browser to the FQDN provided by the LoadBalancer, you should be able to connect to Wordpress and see the content create in the Module-03.
